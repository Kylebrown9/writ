#!/usr/bin/env python3
from typing import Optional
import contextlib
import error_handler
import importlib
import inspect
import json_utils
import os
import parse_input
import re
import subprocess
import sys
import typing
import validate
import wasmtime


class Imports:
    wit_name: Optional[str]
    wasm_file: str
    func: str
    args: list[str]
    classes: dict

    def __init__(self) -> None:
        (binding_path, wit_path, is_verbose, input_args) = parse_input.parse()
        if len(input_args) < 2:
            raise error_handler.Error(
                error_handler.ErrorCode.MISSING_INPUT,
                "Missing either wasm file path or function name.",
            )
        self.wasm_file = input_args[0]
        self.func = input_args[1]
        self.args = [
            json_utils.check_and_load(input_args, index)
            for index in range(2, len(input_args))
        ]
        self.is_verbose = is_verbose

        if wit_path is None:
            self.wit_name = None
        else:
            self.wit_name = re.findall(r"[^\/]+(?=\.)", wit_path)[-1]

            # generate bindings
            export_name = f"{self.wit_name}_export_bindings"
            import_name = f"{self.wit_name}_import_bindings"
            export_path = os.path.join(binding_path, f"{export_name}.py")
            import_path = os.path.join(binding_path, f"{import_name}.py")
            wit_cached_path = os.path.join(binding_path, f"{self.wit_name}.wit")

            WIT_BINDGEN_PATH = validate.check_command(
                "WRIT_WITBINDGEN_PATH", "wit-bindgen"
            )

            validate.check_cached_file_or_generate(
                WIT_BINDGEN_PATH,
                wit_path,
                wit_cached_path,
                export_path,
                import_path,
                is_verbose,
            )

            sys.path.insert(1, binding_path)
            self.imported = importlib.import_module(import_name)
            self.exported = importlib.import_module(export_name)

    def get_types(self, class_name: str) -> list[typing.Any]:
        py_import_classes = inspect.getmembers(
            self.imported,
            lambda x: inspect.isclass(x) and x.__name__ == class_name,
        )
        if not py_import_classes:
            raise error_handler.Error(
                error_handler.ErrorCode.OBJECT_NOT_FOUND,
                f"Class {class_name} is not found in {self.imported}.",
            )
        py_import_class = py_import_classes[0][1]
        py_funcs = inspect.getmembers(
            py_import_class,
            lambda x: inspect.isfunction(x) and x.__name__ == self.func,
        )
        if not py_funcs:
            raise error_handler.Error(
                error_handler.ErrorCode.OBJECT_NOT_FOUND,
                f"Function {self.func} is not found in {py_import_class}. Check if your function name is correct or if you have included it.",
            )
        py_func = py_funcs[0][1]
        signatures = inspect.signature(py_func)
        return [
            signatures.parameters[x].annotation for x in signatures.parameters.keys()
        ]

    def run_without_wit_arg(self) -> str:
        WASMTIME_CMD = validate.check_command("WRIT_WASMTIME_PATH", "wasmtime")
        command = [
            validate.resolve_string(WASMTIME_CMD),
            "run",
            "--invoke",
            self.func,
            self.wasm_file,
        ] + [str(x) for x in self.args]
        try:
            result = subprocess.run(command, capture_output=True)
            return result.stdout.decode("utf-8").strip()
        except:
            raise error_handler.Error(
                error_handler.ErrorCode.UNKNOWN,
                "Unknown error when running the command, likely caused by wrong/unmatched wit specification",
            )

    def run_with_wit_arg(
        self, linker: wasmtime.Linker, store: wasmtime.Store, module: wasmtime.Module
    ) -> str:
        resolved_wit_name = validate.resolve_string(self.wit_name)
        linker_func_name = "add_" + resolved_wit_name + "_to_linker"

        linker_func = getattr(self.exported, linker_func_name)
        linker_func(linker, store, self)

        self.func = self.func.replace("-", "_")

        # process arguments
        py_class_name = "".join(x.capitalize() for x in resolved_wit_name.split("_"))
        type_list = self.get_types(py_class_name)

        # call the class in self_imported files that has the same name as the py_class on necessary parameters

        wasm = getattr(self.imported, py_class_name)(store, linker, module)

        classes = dict(inspect.getmembers(self.imported, inspect.isclass))
        parse_args_helper = json_utils.ParseJson(classes, self.imported)

        try:
            args = parse_args_helper.parse_json_args(
                list(zip(self.args, type_list[2:]))
            )
            result = getattr(wasm, self.func)(store, *args)
        except:
            raise error_handler.Error(
                error_handler.ErrorCode.UNKNOWN,
                "Unknown error when running the command.",
            )
        return json_utils.check_and_dump(json_utils.to_py_obj(result))


def run() -> Optional[str]:
    # initialize
    imports = Imports()
    store = wasmtime.Store()

    try:
        module = wasmtime.Module.from_file(store.engine, imports.wasm_file)
        linker = wasmtime.Linker(store.engine)
        linker.define_wasi()
        linker.define_module(store, "test", module)
        wasi = wasmtime.WasiConfig()
        wasi.inherit_stdout()
        wasi.inherit_stderr()
        store.set_wasi(wasi)

        #  invoke _initialize export
        try:
            maybe_func = linker.get(store, "test", "_initialize")
            maybe_func(store)
        except:
            if imports.is_verbose:
                print("Failed to invoke _initialize.", file=sys.stderr)

        if imports.wit_name is not None:
            return imports.run_with_wit_arg(linker, store, module)
        return imports.run_without_wit_arg()
    except:
        raise error_handler.Error(
            error_handler.ErrorCode.INITIALIZE_MODULE_FAILED,
            "Failed to invoke wasm module.",
        )


if __name__ == "__main__":
    print(run())
