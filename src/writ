#!/usr/bin/env python3

from enum import Enum
from typing import Optional
import error_handler
import importlib
import inspect
import json_utils
import os
import parse_input
import re
import subprocess
import sys
import typing
import validate
import wasmtime


class ErrorCode(Enum):
    INITIALIZE_MODULE_FAILED = "Failed to initialize wasm module."
    INVOKE_INITIALIZE_FAILED = "Failed to invoke _initialize."
    MISSING_INPUT = (
        "Either wasm file path or function name is missing from the input arguments."
    )
    OBJECT_NOT_FOUND = "No object found in target: "
    PATH_NOT_EXIST = "File path doesn't exist: "
    TYPE_NOT_IMPLEMENTED = "Type not implemented: "
    UNKNOWN = "Unknown error, likely caused by wrong/missing arguments."


class Imports:
    wit_name: Optional[str]
    wasm_file: str
    func: str
    args: list[str]
    classes: dict

    def __init__(self) -> None:
        (binding_path, wit_path, input_args) = parse_input.parse()
        if len(input_args) < 2:
            error_handler.return_error(ErrorCode.MISSING_INPUT.value)

        self.wasm_file = input_args[0]
        self.func = input_args[1]
        self.args = [
            json_utils.check_and_load(input_args, index)
            for index in range(2, len(input_args))
        ]

        if wit_path is None:
            self.wit_name = None
        else:
            self.wit_name = re.findall(r"[^\/]+(?=\.)", wit_path)[-1]

            # generate bindings
            export_name = f"{self.wit_name}_export_bindings"
            import_name = f"{self.wit_name}_import_bindings"
            export_path = os.path.join(binding_path, f"{export_name}.py")
            import_path = os.path.join(binding_path, f"{import_name}.py")
            wit_cached_path = os.path.join(binding_path, f"{self.wit_name}.wit")

            WIT_BINDGEN_PATH = validate.check_command(
                "WRIT_WITBINDGEN_PATH", "wit-bindgen"
            )

            validate.check_cached_file_or_generate(
                WIT_BINDGEN_PATH,
                wit_path,
                wit_cached_path,
                export_path,
                import_path,
            )

            sys.path.insert(1, binding_path)
            self.imported = importlib.import_module(import_name)
            self.exported = importlib.import_module(export_name)

    def get_types(self, class_name: str) -> list[typing.Any]:
        py_import_classes = inspect.getmembers(
            self.imported,
            lambda x: inspect.isclass(x) and x.__name__ == class_name,
        )
        py_import_class = error_handler.assert_and_return(
            not py_import_classes,
            ErrorCode.OBJECT_NOT_FOUND.value + "class " + class_name,
            py_import_classes[0][1],
        )
        py_funcs = inspect.getmembers(
            py_import_class,
            lambda x: inspect.isfunction(x) and x.__name__ == self.func,
        )
        py_func = error_handler.assert_and_return(
            not py_funcs,
            ErrorCode.OBJECT_NOT_FOUND.value + "function " + self.func,
            py_funcs[0][1],
        )

        signatures = inspect.signature(py_func)
        return [
            signatures.parameters[x].annotation for x in signatures.parameters.keys()
        ]

    def run_without_wit_arg(self) -> Optional[str]:
        WASMTIME_CMD = validate.check_command("WRIT_WASMTIME_PATH", "wasmtime")
        command = [
            validate.resolve_string(WASMTIME_CMD),
            "run",
            "--invoke",
            self.func,
            self.wasm_file,
        ] + [str(x) for x in self.args]
        try:
            result = subprocess.run(command, capture_output=True)
            return result.stdout.decode("utf-8").rstrip()
        except:
            return None  # error handling here

    def run_with_wit_arg(
        self, linker: wasmtime.Linker, store: wasmtime.Store, module: wasmtime.Module
    ) -> Optional[str]:
        resolved_wit_name = validate.resolve_string(self.wit_name)
        linker_func_name = "add_" + resolved_wit_name + "_to_linker"
        linker_func = getattr(self.exported, linker_func_name)
        linker_func(linker, store, self)

        self.func = self.func.replace("-", "_")

        # process arguments
        py_class_name = "".join(x.capitalize() for x in resolved_wit_name.split("_"))
        type_list = self.get_types(py_class_name)

        # call the class in self_imported files that has the same name as the py_class on necessary parameters
        wasm = getattr(self.imported, py_class_name)(store, linker, module)

        classes = dict(inspect.getmembers(self.imported, inspect.isclass))
        parse_args_helper = json_utils.ParseJson(classes, self.imported)

        try:
            args = parse_args_helper.parse_json_args(
                list(zip(self.args, type_list[2:]))
            )
            result = getattr(wasm, self.func)(store, *args)
        except:
            return None
        return result


def run() -> Optional[str]:
    # initialize
    imports = Imports()

    store = wasmtime.Store()
    try:
        module = wasmtime.Module.from_file(store.engine, imports.wasm_file)

        linker = wasmtime.Linker(store.engine)
        linker.define_wasi()
        linker.define_module(store, "test", module)

        wasi = wasmtime.WasiConfig()
        wasi.inherit_stdout()
        wasi.inherit_stderr()
        store.set_wasi(wasi)

        #  invoke _initialize export
        try:
            maybe_func = linker.get(store, "test", "_initialize")
            maybe_func(store)
        except:
            print(ErrorCode.INVOKE_INITIALIZE_FAILED.value, file=sys.stderr)

        if imports.wit_name is not None:
            return imports.run_with_wit_arg(linker, store, module)
        return imports.run_without_wit_arg()
    except:
        print(ErrorCode.INITIALIZE_MODULE_FAILED.value, file=sys.stderr)


if __name__ == "__main__":
    result = run()
    if result is None:
        print(ErrorCode.UNKNOWN.value, file=sys.stderr)
    else:
        json_result = json_utils.check_and_dump(json_utils.to_py_obj(result))
        print(json_result)
